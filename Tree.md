Tree
==================

### 1. Tree의 개념 및 특징

1. 그래프의 한 종류이다. '최소 연결 트리' 라고도 불린다.
2. 트리는 비선형 자료구조로 계층적 관계를 표현하는 계층 모델이다.
3. 트리는 하나의 루트 노드를 갖는다.  
4. 루트 노드는 0개 이상의 자식 노드를 갖고 있다.  
5. 그 자식 노드 또한 0개 이상의 자식 노드를 갖고 있고, 이는 반복적을 정의된다.  
6. 노드들과 노드들을 연결하는 간선들로 구성되어 있다.
7. 노드들은 특정 순서로 나열될 수도 있고, 그럴 수 없을 수도 있다.
8. 각 노드는 부모 노드로의 연결이 있을 수도 있고 없을 수도 있다.
9. 각 노드는 어떤 자료형으로도 표현 가능하다.
10. 사이클이 없다.
11. 노드가 N개인 트리는 항상 N-1개의 간선(edge)을 가진다.
12. 루트에서 어떤 노드로 가는 경로는 유일하다(임의의 두 노드 간의 경로도 유일하다.)
13. 한 개의 루트 노드만이 존재하며, 모든 자식 노드는 한 개의 부모 노드만을 가진다.
---------------------  
  
### 2. Tree의 용어

1. Node(노드) : 트리를 구성하고 있는 각 요소
2. Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선
3. Root Node : 최상위 계층에 존재하는 노드
4. Level : 트리의 특정 깊이를 가지느 노드의 집합
5. Degree(차수) : 하위 트리 개수 / 간선 수 = 각 노드가 지닌 가지의 수
6. Terminal Node(= leaf Node, 단말 노드) : 하윙 다르 노드가 연결되어 있지 않은 노드
7. Internal Node(내부 노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함
---------------------

### 3. 트리의 종류

  ### * 이진트리(Binary Tree)
    : 트리를 구성하는 노드들의 최대 차수(degree)가 2인 노드들로 구성되는 트리
    
    ** 완전 이진 트리
      : 트리를 구성하고 있는 임의의 두 단말 노드의 레벨 차이가 1 이하이다. 
      : 마지막 레벨을 제외한 모든 레벨에 존재할 수 있는 모든 노드를 갖고 있다. 
      : 왼쪽에서 오른쪽으로 채워지는 이진트리이다. 
    
    ** 전 이진 트리
      : 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리. 
      
    ** 포화 이진 트리
      : 전 이진 트리이면서 포화 이진 트리인 경우. 
      : 모든 단말 노드는 같은 높이에 있어야 하며, 마지막 단계에서 노드의 개수가 최대가 되어야 한다. 
      : 모든 내부 노드는 두개의 자식 노드를 갖는다. 
      : 노드의 수가 2^k-1개다.
    
    ** 이진 트리 순회
      - 중우 순회(inorder traversal)
        : 왼쪽 서브트리 -> 루트 -> 오른쪽 서브트리
      - 후위 순회(postorder traversal)
        : 왼쪽 서브트리 -> 오른쪽 서브트리 -> 루트
      - 전위 순회(preorder traversal)
        : 루트 -> 왼쪽 -> 오른쪽
      
  ### * 이진 탐색 트리(Binary Search Tree)
    : 이진 탐색을 쉽게 할 수 있도록 만들어짐. 
    : 모든 왼쪽 자식 노드 <= N < 모든 오른쪽 자식 노드(모든 노드 N에 대해서 반드시 참). 
    : 이진 탐색 트리의 노드에 저장된 키는 유일하다. 
    : 탐색 연산은 평균 O(log n)의 시간 복잡도. 
    : 비교적 삽입, 삭제가 효율적인 자료구조. 
    : 편향 트리가 될 수 있다. (저장 순서에 따라 계소 한 쪽으로만 노드 추가 발생 O(n). 
    : 균형잡힌 이진 검색 트리를 고안 -> 레드블랙트리, AVL

  ### * Red-Black Tree
    : 자가균형이진탐색 트리 -> 연관배열 등을 구현하는데 쓰임. 
    : 이진 탐색 트리가 편햐 트리가 될 경우를 방지함. 
    : 자료의 삽입과 삭제, 검색에서 최악의 경우에도 일정한 실행 시간을 보장
      -> 실시간 처리와 같은 실행시간이 중요한 경우에 유용. 
      -> 일정한 실행 시간을 보장하는 기하학 계산에 쓰이는 많은 자료 구조에 사용됨. 
    : 조건
      -> Root Property : 루트노드의 색깔은 검정(추가되는 노드는 빨강). 
      -> External Property : 모든 external 노드의 색은 검정. 
      -> Internal Property : 빨강 노드의 자식은 검정. 
      -> No Double Red : 빨간색 노드가 연속으로 나올 수 없다. 
      -> Depth Property : 모든 리프노드에서 Black Depth는 같다. (리프노드에서 루트노드까지 가는 경로에서 만나는 블랙노드 개수는 같다). 
    : Double Red 해결 전략 ( 현재 insert된 노드의 부모의 형제 노드 == w)
      -> w == Black -> Restructuring(보통 O(1)~ O(logn))
          1. 나(z)와 내 부모(v), 내 부모의 부모(Grand Parent)를 오름차순으로 정렬
          2. 무조건 가운데 있는 값을 부모로 만들고 나머지 둘을 자식으로 만든다.
          3. 올라간 가운데 있는 값을 검정(Black)으로 만들고 그 두자식들을 빨강(Red)로 만든다.
          
      -> w == Red -> Recoloring(최악의 경우 Root까지 갈 수 있음)
          1. 현재 insert된 노드(c)의 부모(p)와 그 형제(u)를 검정(Black)으로 하고 Grand Parent(내 부모의 부모)를 빨강(Red)로 한다.
          2. Grand Parent(내 부모의 부모)가 Root node가 아니었을 시 Double Red가 다시 발생 할 수 있다.
          
  ### * AVL Tree
      블로그 참고: https://www.zerocho.com/category/Algorithm/post/583cacb648a7340018ac73f1
   
  ### * AVL Tree VS Red-Black Tree
    : A
